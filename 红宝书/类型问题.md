# JavaScript类型问题

## 一、Number类型

### 双精度浮点数问题

JavaScript 中所有数字包括整数和小数都只有一种类型 即 Number类型 它的实现遵循 IEEE 754 标准

浮点型简单来说就是表示带有小数的数据,而恰恰小数点可以在相应的二进制的不同位置浮动，可能是这样就被定义成浮点型了

>​       对于一个整数，我们可以很方便的在十进制与二进制中转换，但是对于一个浮点数来说不是这么容易——因为小数点的存在。对于浮点数来说，小数点的位置不是固定的（小数点后面的数的个数不定），所以如何存储小数点是一个挑战。后来人们想出用科学计数法通常如这般： 1.01*2^4 来表示浮点数，这样的好处是：小数点的位置固定下来了。因为计算机只能用二进制(0或1)表示 ，二进制转换为科学记数法的公式如下：X=a*2^e

### 符号位

1位  0正 1负

### 指数位(取得数值范围)(最大数值)

> 最大11位，即11位最大为11个二进制（11111...）即指数部分能表示的最大值是 2047（2^11-1）
>
> 取中间值进行偏移，用来表示负指数，也就是说指数的范围是 [-1023,1024] 。
>
> 因此，这种存储结构能够表示的数值范围为 2^1024 到 2^-1023 ，超出这个范围的数无法表示 。2^1024 和 2^-1023 转换为科学计数法如下所示：
>
> 1.7976931348623157 × 10^308
>
> 5 × 10^-324

```js
// 最大数值
Number.MAX_VALUE; // 1.7976931348623157e+308 

Number.MIN_VALUE; // 5e-324
```



### 小数位（精度范围）(最大的安全整数)

> 指数部分一共有11个二进制位，因此大小范围就是0到2047。IEEE 754 规定，如果指数部分的值在0到2047之间（不含两个端点），那么有效数字的第一位默认总是1,不保存在64位浮点数之中。
>
> JavaScript 提供的有效数字最长为53个二进制位。
>
> 精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。

```js
Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996
```

```js
// 最大的安全整数
console.log(Number.MAX_SAFE_INTEGER) ; // 9007199254740991
console.log(Number.MIN_SAFE_INTEGER) ; // -9007199254740991
```



### 类型转换

- Number
  - 主要是转型函数，可用于任何数据类型
  - 类型转换
    - null - 0
    - Undefined - NaN
    - Boolean - 1/0
    - 数字直接返回
    - 字符串
      - 数值、包含+- 转换为十进制
      - 浮点数 - 忽略前面的0
      - 十六进制 - 转换为对应十六进制
      - 空 - 0
      - 其他 NaN
    - 对象 调用valueOf
    - Symbol 不能转为数值 -----TypeError
- parseInt
  - 主要讲字符串转为数值
  - 整数
  - 从第一个非空字符开始，如果第一个不是数值，加减就直接返回NaN
  - 截断后续的不能识别的字符
  - 能识别十六进制
- parseFloat
  - 主要讲字符串转为数值
  - 可识别第一个小数点
  - 小数
  - 从第一个非空字符开始，如果第一个不是数值，加减就直接返回NaN

